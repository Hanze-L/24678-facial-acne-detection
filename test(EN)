import cv2
import numpy as np
import os

class AcneDetector:
    def __init__(self, debug=True):
        self.debug = debug
        self.red_params = {
            'top_percentage': 0.005,  # Select the top 0.1% reddest points
            'min_distance': 50        # Minimum distance between two red points
        }

    def show_debug_image(self, title, image):
        if self.debug:
            cv2.imshow(title, image)
            cv2.waitKey(0)

    def find_red_peaks(self, a_channel):
        """Find the reddest regions in the A channel."""
        # Get image dimensions
        height, width = a_channel.shape
        total_pixels = height * width
        
        # Calculate the number of pixels to select (top 0.1% reddest pixels)
        num_peaks = int(total_pixels * self.red_params['top_percentage'])
        
        # Find the positions of the top N reddest pixels
        flat_indices = np.argpartition(a_channel.ravel(), -num_peaks)[-num_peaks:]
        row_indices, col_indices = np.unravel_index(flat_indices, a_channel.shape)
        
        # Combine coordinates with their respective values
        coords_and_values = list(zip(row_indices, col_indices, a_channel[row_indices, col_indices]))
        
        # Sort by value in descending order
        coords_and_values.sort(key=lambda x: x[2], reverse=True)
        
        # Use non-maximum suppression to filter peaks
        selected_peaks = []
        for y, x, val in coords_and_values:
            too_close = False
            for selected_y, selected_x, _ in selected_peaks:
                distance = np.sqrt((y - selected_y)**2 + (x - selected_x)**2)
                if distance < self.red_params['min_distance']:
                    too_close = True
                    break
            
            if not too_close:
                selected_peaks.append((y, x, val))
        
        return selected_peaks

    def visualize_red_detection(self, image):
        """Detect red regions using the LAB color space."""
        # Convert to LAB color space
        lab = cv2.cvtColor(image, cv2.COLOR_BGR2LAB)
        l, a, b = cv2.split(lab)
        
        # Normalize the A channel for visualization
        a_normalized = cv2.normalize(a, None, 0, 255, cv2.NORM_MINMAX)
        
        # Create a pseudo-color image
        a_colormap = cv2.applyColorMap(a_normalized, cv2.COLORMAP_JET)
        
        # Find red peaks
        red_peaks = self.find_red_peaks(a)
        
        # Mark detected regions on the original image and the colormap
        result_image = image.copy()
        colormap_with_marks = a_colormap.copy()
        
        # Create a heatmap for visualization
        heatmap = np.zeros_like(a_normalized)
        
        # Mark detected red peaks on the image
        for y, x, val in red_peaks:
            # Draw circles on the result image
            cv2.circle(result_image, (x, y), 5, (0, 0, 255), 2)  # Red circle
            cv2.circle(result_image, (x, y), 1, (0, 255, 0), -1) # Green center
            
            # Draw circles on the colormap
            cv2.circle(colormap_with_marks, (x, y), 5, (255, 255, 255), 2)  # White circle
            cv2.circle(colormap_with_marks, (x, y), 1, (0, 255, 0), -1)     # Green center
            
            # Add Gaussian distribution to the heatmap
            y_coords, x_coords = np.ogrid[-y:a_normalized.shape[0]-y, -x:a_normalized.shape[1]-x]
            mask = x_coords*x_coords + y_coords*y_coords <= 100
            heatmap[mask] = np.maximum(heatmap[mask], val)
        
        # Normalize the heatmap and create a color version
        heatmap_normalized = cv2.normalize(heatmap, None, 0, 255, cv2.NORM_MINMAX).astype(np.uint8)
        heatmap_color = cv2.applyColorMap(heatmap_normalized, cv2.COLORMAP_JET)
        
        # Create a translucent overlay effect
        alpha = 0.3
        overlay = cv2.addWeighted(image, 1-alpha, heatmap_color, alpha, 0)
        
        results = {
            'original': image,
            'a_channel': a_normalized,
            'a_colormap': a_colormap,
            'colormap_with_marks': colormap_with_marks,
            'heatmap': heatmap_color,
            'overlay': overlay,
            'result': result_image
        }
        
        return results

    def analyze_image(self, image_path):
        """Analyze the image and display processing steps."""
        # Read the image
        image = cv2.imread(image_path)
        if image is None:
            raise ValueError("Failed to read image")

        # Resize the image if necessary
        height, width = image.shape[:2]
        max_dimension = 800
        if max(height, width) > max_dimension:
            scale = max_dimension / max(height, width)
            image = cv2.resize(image, (int(width * scale), int(height * scale)))

        # Get processing results
        results = self.visualize_red_detection(image)
        
        # Display all processing steps
        for title, img in results.items():
            self.show_debug_image(title, img)
            # Save results
            cv2.imwrite(f"{title}.jpg", img)
            print(f"Saved: {title}.jpg")

if __name__ == "__main__":
    try:
        detector = AcneDetector(debug=True)
        image_path = input("Enter image path: ")
        detector.analyze_image(image_path)
        
        cv2.waitKey(0)
        cv2.destroyAllWindows()
        
    except Exception as e:
        print(f"Error occurred: {str(e)}")
